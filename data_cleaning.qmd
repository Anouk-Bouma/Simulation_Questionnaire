---
title: "analysis_script"
format: html
editor: visual
---

<!--# Hey bestie, before submitting the final version -> ctrl + f: 'NOTE' to check if all notes are evaluated and removed -->

## Version Control

```{r}
renv::restore()

library(tidyr)
library(dplyr)
library(readxl)
library(ggplot2)
library(stringr)
library(purrr)
library(writexl)
library(openxlsx)
library(tibble)
```

## Initial simple data cleaning

```{r}
### Loading the data into R 
data <- read_excel("simulation_survey_data_direct_qualtrics_download.xlsx")

# Removing irrelevant and identifying columns:
# StartDate, EndDate, Status, RecordedDate, ResponseId, DistributionChannel
# UserLanguage
data <- data %>% select(-StartDate, -EndDate, -Status, -RecordedDate, 
                        -ResponseId, -DistributionChannel, -UserLanguage)
# Removing the first row as this contains a second header instead of data
data <- data[-1,]
```

## Participant-specific simple data cleaning

```{r}
####
## Exclude everyone that did not fill out any content-related question (Q5 and further)

# Step 1: select all columns from 15 onward (which is column where Q5 is in)
cols_from_15 <- select(data, 15:ncol(data))

# Step 2: only keep participants that have data for at least one of those selected columns (i.e, select all rows where not all selected columns are NA or -99)
data_filtered <- data %>%
  filter(rowSums(is.na(cols_from_15) | cols_from_15 == '-99') < ncol(cols_from_15))

#### (NOTE: might want to move this part to descriptives + calculate full vs partial responses)
# Calculate reponse rate
n_invitations <- 695
n_participants <- 224
response_rate <- n_participants/n_invitations # = 0.3223

####
## Add an ID variable to the dataset
data_filtered <- data_filtered %>%
  mutate(ID = paste0("id", row_number())) %>%
  relocate(ID) # put ID variable column as the first column of the dataset

####
# Change columns with values into type numeric
data_filtered <- data_filtered %>%
  mutate(across(
    where(~ is.character(.) &&
            all(str_detect(., "^\\d+$") | is.na(.) | str_detect(., "-99"))),
    as.numeric
  ))
```

## Save intermediate dataset to continue with

```{r}

data <- data_filtered

# Save data as Excel file
write.xlsx(data, file = "survey_intermediate_datafile.xlsx")
```

## Evaluating text results

In this block we will extract all textual results that need to be evaluated to decide what to do with them. The previously saved dataset can be useful to open when evaluating textual data because evaluating what to do with open answers might depend on other answers given by the same participant.

```{r}

# Define the text columns you want to extract
text_cols <- c("Q2_4_TEXT", "Q7a_12_TEXT", "Q7b_12_TEXT", 
               "Q10a_12_TEXT", "Q10b_12_TEXT", 
               "Q13a_12_TEXT", "Q13b_12_TEXT",
               "Q16a_15_TEXT", "Q16b_15_TEXT",
               "Q18a_10_TEXT", "Q18b_9_TEXT",
               "Q19_6_TEXT", "Q20_8_TEXT",
               "Q22_11_TEXT", "Q23_5_TEXT",
               "Q24_13_TEXT", "Q25_12_TEXT",
               "Q30")

# Create a named list of tibbles
text_list <- map(text_cols, function(col) {
  data_filtered %>%
    filter(.data[[col]] != "-99", !is.na(.data[[col]])) %>%
    select(ID, text = all_of(col))
}) %>%
  set_names(text_cols)

# Write to Excel with one sheet per column
#write_xlsx(text_list, "text_responses.xlsx")
```

## Anonymizing in Excel

Before going to the next step, the open answers were all anonymized by hand in Excel. Any part of an open answer that allows for an individual to be identified is replaced by '\[redacted\]'. This step does not change anything in terms of reproducibility of the other steps in this script.

## Load anonymized dataset to work with

```{r}

# Load the anonymized data here
data <- read.xlsx("survey_data_anonymized_raw.xlsx")
```

## Data Cleaning following evaluation of textual results

```{r}

####
# Removing participants we decided to exclude based on their answers

id_remove <- c("id2", "id32", "id94")

data <- data %>%
  filter(!ID %in% id_remove)


####
# Changes in individual answers based on open answer options
# Addition of new answer categories based on themes found in open answers (see codebook for details)
data <- data %>%
  add_column(Q16a_16_NEW = NA_integer_, .after = "Q16a_15_TEXT") %>% # Keyword: Not Applicable
  add_column(Q18a_11_NEW = NA_integer_, .after = "Q18a_10_TEXT") %>% # Keyword: Not Applicable
  add_column(Q16a_17_NEW = NA_integer_, .after = "Q16a_16_NEW") %>% # Keyword: Low Occurrence
  add_column(Q18a_12_NEW = NA_integer_, .after = "Q18a_11_NEW") %>% # Keyword: Uncommon
  add_column(Q18a_13_NEW = NA_integer_, .after = "Q18a_12_NEW") %>% # Keyword: Alternative Check
  add_column(Q20_9_NEW = NA_integer_, .after = "Q20_8_TEXT") %>% # Keyword: Field
  add_column(Q20_10_NEW = NA_integer_, .after = "Q20_9_NEW") %>% # Keyword: Experience
  add_column(Q20_11_NEW = NA_integer_, .after = "Q20_10_NEW") # Keyword: Not Available

# Changing the score to 1 for participant as coded
data <- data %>%
  mutate(Q16a_16_NEW = if_else(ID %in% c("id9", "id69"), 1, NA_integer_)) %>%
  mutate(Q18a_11_NEW = if_else(ID %in% c("id9", "id156", "id161", "id108", "id139"), 1, NA_integer_)) %>%
  mutate(Q16a_17_NEW = if_else(ID %in% c("id108", "id129", "id197", "id210"), 1, NA_integer_)) %>%
  mutate(Q18a_12_NEW = if_else(ID %in% c("id92", "id158"), 1, NA_integer_)) %>%
  mutate(Q18a_13_NEW = if_else(ID %in% c("id60", "id71", "id137", "id178"), 1, NA_integer_)) %>%
  mutate(Q20_9_NEW = if_else(ID %in% c("id27", "id36", "id105", "id165", "id191", "id204"), 1, NA_integer_)) %>%
  mutate(Q20_10_NEW = if_else(ID %in% c("id35", "id36", "id43", "id135", "id140"), 1, NA_integer_)) %>%
  mutate(Q20_11_NEW = if_else(ID %in% c("id161", "id165", "id188", "id213"), 1, NA_integer_))

# Changing the score in the 'other' option to 2/3 (see codebook)

# NOTE: Add code here!!!




# Changing existing data (that is clearly wrong) based on open answers

data <- data %>%
  # Q16a: participants that indicated they did not report missings/nonconvergence because there were none, but did not     indicate this as the reasons for not reporting this information in the answer options
  mutate(Q16a_6 = if_else(ID %in% c("id96", "id159", "id164", "id178", "id199"), 1, Q16a_6)) %>%
  # id9: change answers to questions about research guidelines
  mutate(Q19_5 = if_else (ID %in% c("id9"), 1, Q19_5)) %>%
  mutate(Q19_6 = if_else (ID %in% c("id9"), 1, Q19_6)) %>%
  mutate(Q20_8 = if_else (ID %in% c("id9"), 1, Q20_8)) %>%
  mutate(Q20_8_TEXT = if_else (ID %in% c("id9"), "Report all that is relevant to the research question", Q20_8_TEXT)) %>%
  # id125: change answer to Q23_1 to TRUE
  mutate(Q23_1 = if_else(ID %in% c("id125"), 1, Q23_1)) %>%
  # id14: change answer Q24_3 to TRUE
  mutate(Q24_3 = if_else(ID %in% c("id14"), 1, Q24_3)) %>%
  # Change answers for participants that indicated that they reported all missings/nonconv. But in the comments indicated   that they did not report it because there were none in their case.
  mutate(Q14 = if_else(ID %in% c("id21", "id85", "117", "122"), 3, Q14)) %>%
  mutate(Q15 = if_else(ID %in% c("id21", "id85", "117", "122"), NA_integer_, Q15)) %>%
  mutate(Q16a_6 = if_else(ID %in% c("id21", "id85", "117", "122"), 1, Q16a_6)) %>%
  # Change answer options for Q16a to 0 for all options except for Q16_6
  mutate(across(c(Q16a_1, Q16a_2, Q16a_3, Q16a_4, Q16a_5, # all answer options except for Q16a_6
                  Q16a_7, Q16a_8, Q16a_9, Q16a_10, Q16a_11, 
                  Q16a_12, Q16a_13, Q16a_14, Q16a_15),
                ~ if_else(ID %in% c("id21", "id85", "117", "122"),
                          0,
                          .))) %>%
  # Change answer on slider reproducibility to missing for participant that indicated confusion over question
  mutate(Q28_1 = if_else(ID %in% c("id61"), NA, Q28_1))
  

  
  ####
# Impossible combinations

# Listing impossible combinations:





####
# Slider check
```

## Variable combining

```{r}

## Creating the variable 'new_method' that indicates if one of the authors has been involved in developing one or multiple methods that are part of their paper

data <- data %>%
  mutate(new_method = case_when(Q2 == "1.0" | 
                                Q2 == "2.0" | 
                                Q3 == "1.0" ~ 1, 
                                .default = 0))
```

## Save final dataset after all cleaning steps are done

```{r}

```
