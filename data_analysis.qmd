---
title: "data_analysis"
format: html
editor: visual
---

## Version Control

```{r}
renv::restore()

library(tidyverse)
library(readxl)
library(ggplot2)
library(stringr)
library(purrr)
library(writexl)
library(openxlsx)
```

## Loading the data

```{r}

# Load the cleaned data here
load("survey_data_cleaned.RData")

# Load questionnaire metadata
meta <- read.xlsx("question_labels.xlsx", sheet = "codebook")
```

## Descriptives

-   

```{r}

sample_sizes <- meta %>%
  distinct(question_group, question_code) %>%
  arrange(question_group) %>%
  group_by(question_group) %>%
  summarise(
    sample_col = first(question_code),
    n = sum(!is.na(data[[sample_col]])),
    .groups = "drop"
  )

# Function to get answer options per question (NOTE: not needed anymore)
get_question_columns <- function(metadata = meta, question) {
meta_group <- metadata %>%
    filter(question_group == question) %>%
    arrange(order)

return(meta_group)
}
```

## Descriptives table

```{r}

#' Title
#'
#' @param data dataset containing the respondent survey data
#' @param metadata dataset containing metadata about the survey including question numbers, answer categories and variable names.
#' @param sample_sizes a dataframe containing the sample size per question
#'
#' @returns
#'
#' @examples
create_question_table <- function(data, metadata, sample_sizes) {

  all_tables <- list()

  # Ensure metadata$value is numeric so it can be joined later
  metadata <- metadata %>%
    mutate(value = suppressWarnings(as.numeric(value)))
  
  # Loops over every question: question_group is a question (e.g., Q7a)
  for (question in unique(metadata$question_group)) {

    # Metadata for this question
    meta_group <- metadata %>%
      filter(question_group == question) %>% # 'question' is the loop index
      arrange(order)
    
    # Take order index for this question
    q_order <- unique(meta_group$question_order)

    # Get sample size for this question
    sample_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n)

    # MULTI-SELECT QUESTION -----------------------------------------
    if (n_distinct(meta_group$question_code) > 1) { # check if multi-select
      
      # Identify columns in participant data for this question and extract
      option_cols <- meta_group$question_code
      subdata <- data[, option_cols]
      #answered <- rowSums(!is.na(subdata)) > 0 #NOTE: delete line?

      tbl <- subdata %>%
        summarise(across(all_of(option_cols), 
                         ~ sum(.x == 1, na.rm = TRUE))) %>%
        pivot_longer(
          cols = everything(),
          names_to = "question_code",
          values_to = "N"
        ) %>%
        # add metadata (answer labels to data)
        left_join(meta_group, by = "question_code") %>%
        mutate(
          Question = question,
          question_order = q_order,
          sample_size = sample_n
        ) %>%
        select(Question, 
               question_order,
               variable_name,
               answer_label, 
               N, 
               sample_size, 
               order)

      all_tables[[question]] <- tbl
      
    } else {

      # SINGLE-SELECT QUESTION ---------------------------------------
      qcol <- meta_group$question_code[1]
      data[[qcol]] <- suppressWarnings(as.numeric(data[[qcol]]))

      tbl <- meta_group %>%
        select(value, variable_name, answer_label, order) %>%
        left_join(
          data %>%
            filter(!is.na(.data[[qcol]])) %>%
            group_by(value = .data[[qcol]]) %>%
            summarise(N = n(), .groups = "drop"),
          by = "value"
        ) %>%
        mutate(
          N = replace_na(N, 0),
          Question = question,
          question_order = q_order,
          sample_size = sample_n
        ) %>%
        select(Question, 
               question_order,
               variable_name,
               answer_label, 
               N, 
               sample_size, 
               order)

      all_tables[[question]] <- tbl
      
    }
  }

  # Bind all rows
  result <- bind_rows(all_tables) %>%
    arrange(question_order, order) %>%
    select(-order)

  # ---- NEW: calculate Percentage at the very end ----
  result <- result %>%
    mutate(
      Percentage = ifelse(
        sample_size == 0, 0, round(N / sample_size * 100, 1))
    ) %>%
    mutate(
      N_percentage = paste0(N, " (", Percentage, "%)")
    ) %>%
    # drop column question_order from dataframe
    select(!question_order)

  result
}


descriptives_table <- create_question_table(data, meta, sample_sizes)

```

## Save table for use in paper

```{r}

write.xlsx(descriptives_table, file = "test_table_desc.xlsx")
```

## Descriptives continues variables

```{r}

vars <- c("Q1", "Q27_1", "Q28_1", "Q29_1")

# Create an empty dataframe to fill
descriptives_continues <- data.frame(
  variable = vars,
  mean = NA_real_,
  sd = NA_real_,
  n = NA_integer_,
  stringsAsFactors = FALSE
)

# Loop through variables and fill the table
for (i in seq_along(vars)) {
  v <- vars[i]
  
  # extract variable and recode -99 and 999 to NA
  x <- data[[v]]
  x[x %in% c(-99, 999)] <- NA
  
  # fill values
  descriptives_continues$mean[i] <- mean(x, na.rm = TRUE)
  descriptives_continues$sd[i]   <- sd(x, na.rm = TRUE)
  descriptives_continues$n[i]    <- sum(!is.na(x))
}

descriptives_continues
  
```

## Correlations

```{r}

vars <- c("Q1", "Q27_1", "Q28_1", "Q29_1")

# Extract only the chosen variables
vars_for_correlations <- data[vars]

# Change missing values to NA (-99 and 999)
vars_for_correlations[vars_for_correlations == -99] <- NA
vars_for_correlations[vars_for_correlations == 999] <- NA

# Compute pairwise correlations using pairwise complete observations
cor_matrix <- cor(vars_for_correlations, use = "pairwise.complete.obs")

cor_matrix

write.xlsx(cor_matrix, "cor_matrix.xlsx")


 # ----------- NOTE: not done yet here: --------- #

# Calculating the t-statistic with the finite population correction factor
r <- 0.3341475
rho <- 0
n <- 196
N <- 949 # Number of included articles (= population size)

t_corrected <- function(r, rho, n, N) {
  t <- (r - rho)/(sqrt((1-r^2)/(n - 2))*sqrt((N-n)/(N-1)))
  return(t)
}

# two-sided t-test
p_value <- function(t_value, df) { 2 * (1 - pt(abs(t_value), df)) }


# Run the t-test
t_value <- t_corrected(r, rho, n, N)
p <- p_value(t_value, df = n - 2)

```

## Plotting

For every question, there have to be the following plots:

-   Frequencies overall

-   Frequencies split over neutral/non-neutral

-   Make option in function to split by a specific variable (ideally plotted in the same graph). And make an option to select freqencies or percentages in the function.

-   a/b versions of the same question should also be in combined plots

-   n in the title of the plots

## Specifying function for plots per question

```{r}

plot_question <- function(
    data = data, metadata = meta, question, wrap_width = 60) {
  
  # Extract relevant metadata rows for this question
  meta_group <- metadata %>%
    filter(question_group == question) %>%
    arrange(order)
  
  # Wrap the question text so long titles look clean
  wrapped_title <- stringr::str_wrap(meta_group$item[1], width = wrap_width)

  # --- MULTI-SELECT QUESTIONS (multiple columns in data) ---
  if (n_distinct(meta_group$question_code) > 1) { 
    
    # All answer options that belong to this multi-select question
    all_options <- meta_group %>%
      select(question_code, answer_label, order)
    
    # Count how many respondents selected each option
    # A left join ensures that options with 0 selections still appear
    plot_data <- all_options %>%
      left_join(
        data %>%
          pivot_longer(
            cols = all_of(meta_group$question_code),
            names_to = "question_code",
            values_to = "selected"
          ) %>%
          filter(selected == 1) %>%     # keep only chosen options
          count(question_code),         # count selections
        by = "question_code"
      ) %>%
      mutate(n = replace_na(n, 0))      # ensure missing counts become 0
    
    # Order answer labels according to metadata (not alphabetical)
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label))
    
    # ----- Plot for multi-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = n)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +             # horizontal bars
      scale_y_reverse() +        # bars go right → left
      geom_text(aes(label = n),  # count labels
                hjust = -0.2, size = 3) +
      scale_x_discrete(
        labels = ~ stringr::str_wrap(.x, width = wrap_width),
        position = "top"         # move y-axis labels to the right side
      ) +
      labs(x = NULL, y = "Count", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
    
  } else {
    
    # --- SINGLE-SELECT QUESTIONS (one column in data) ---
    qcol <- meta_group$question_code[1]
    
    # All options available for this question
    all_options <- meta_group %>%
      select(value, answer_label, order)
    
    # Count how many respondents selected each option
    # Left join ensures missing categories appear with 0
    plot_data <- all_options %>%
      left_join(
        data %>%
          filter(!is.na(.data[[qcol]])) %>%       # ignore missing responses
          group_by(value = .data[[qcol]]) %>%     # match metadata$value
          summarise(n = n(), .groups = "drop"),
        by = "value"
      ) %>%
      mutate(n = replace_na(n, 0))
    
    # Keep original answer order
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label))
    
    # ----- Plot for single-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = n)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +
      scale_y_reverse() +
      geom_text(aes(label = n),
                hjust = -0.1, size = 3) +
      scale_x_discrete(
        labels = ~ stringr::str_wrap(.x, width = wrap_width),
        position = "top"
      ) +
      labs(x = NULL, y = "Count", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
  }
}


#plot_question(data, meta, "Q16a")

```

## Plot with percentages (instead of counts)

<!--# This does not work yet. The function has a hard time deciding the number of participants per question. I need the number of participants per question for descriptives too. So maybe start with that tomorrow morning and then incorporate that into this function (or ideally combine the two functions together) -->

```{r}
plot_question_percentage <- function(
    data = data, metadata = meta, question, wrap_width = 60) {
  
  # Extract relevant metadata rows for this question
  meta_group <- metadata %>%
    filter(question_group == question) %>%
    arrange(order)
  
  # Wrap the question text so long titles look clean
  wrapped_title <- stringr::str_wrap(meta_group$item[1], width = wrap_width)

  # --- MULTI-SELECT QUESTIONS (multiple columns in data) ---
  if (n_distinct(meta_group$question_code) > 1) { 
    
    # All answer options that belong to this multi-select question
    all_options <- meta_group %>%
      select(question_code, answer_label, order)
    
    # Count selections per option
    plot_counts <- data %>%
      pivot_longer(
        cols = all_of(meta_group$question_code),
        names_to = "question_code",
        values_to = "selected"
      ) %>%
      filter(selected == 1) %>% 
      count(question_code) 
    
    # Total number of respondents
    total_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n) %>% # pull the column n
      .[1] # take first element from column n

    # Add missing options as 0 + compute percentages
    plot_data <- all_options %>%
      left_join(plot_counts, by = "question_code") %>%
      mutate(
        n = replace_na(n, 0),
        pct = 100 * n / total_n            # percentage
      )

    # Order answer labels according to metadata
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label
        ))
    
    # ----- Plot for multi-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = pct)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +
      scale_y_reverse(limits = c(100, 0)) +        # 0–100% axis always
      geom_text(aes(label = sprintf("%.1f%%", pct)),
                hjust = -0.2, size = 3) +
      scale_x_discrete(labels = ~ stringr::str_wrap(.x, width = wrap_width),
                       position = "top") +
      labs(x = NULL, y = "Percent", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
    
  } else {
    
    # --- SINGLE-SELECT QUESTIONS (one column in data) ---
    qcol <- meta_group$question_code[1]
    
    # All options available for this question
    all_options <- meta_group %>%
      select(value, answer_label, order)
    
    # Count responses per option
    plot_counts <- data %>%
      filter(!is.na(.data[[qcol]])) %>%
      group_by(value = .data[[qcol]]) %>%
      summarise(n = n(), .groups = "drop")
    
    # Total number of respondents
    total_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n) %>% # pull the column n
      .[1] # take first element from column n
    
    # Add missing options + compute percentages
    plot_data <- all_options %>%
      left_join(plot_counts, by = "value") %>%
      mutate(
        n = replace_na(n, 0),
        pct = 100 * n / total_n
      )
    
    # Keep original answer order
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label))
    
    # ----- Plot for single-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = pct)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +
      scale_y_reverse(limits = c(100, 0)) +        # 0–100% axis always
      geom_text(aes(label = sprintf("%.1f%%", pct)),
                hjust = -0.1, size = 3) +
      scale_x_discrete(labels = ~ stringr::str_wrap(.x, width = wrap_width),
                       position = "top") +
      labs(x = NULL, y = "Percent", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
  }
}


```

## Making some plots

```{r}

plot_questions <- c("Q2", "Q3", "Q4", "Q5", "Q6", "Q7a", "Q7b", "Q8", "Q9", "Q10a", "Q10b", "Q11", "Q12", "Q13a", "Q13b", "Q14", "Q15", "Q16a", "Q16b", 
  "Q17", "Q18a", "Q18b", "Q19", "Q20", "Q21", "Q22", "Q23", "Q24", "Q25")

for (i in 1:length(plot_questions)) {
  print(plot_question(data, meta, plot_questions[i]))
  print(plot_question_percentage(data, meta, plot_questions[i]))
}

```
