---
title: "data_analysis"
format: html
editor: visual
---

## Version Control

```{r}
renv::restore()

library(tidyverse)
library(readxl)
library(ggplot2)
library(stringr)
library(purrr)
library(writexl)
library(openxlsx)
```

## Loading the data

```{r}

# Load the cleaned data here
load("survey_data_cleaned.RData")

# Load questionnaire metadata
meta <- read.xlsx("question_labels.xlsx", sheet = "codebook")
```

## Descriptives

-   

```{r}

sample_sizes <- meta %>%
  distinct(question_group, question_code) %>%
  arrange(question_group) %>%
  group_by(question_group) %>%
  summarise(
    sample_col = first(question_code),
    n = sum(!is.na(data[[sample_col]])),
    .groups = "drop"
  )

# Function to get answer options per question
get_question_columns <- function(metadata = meta, question) {
meta_group <- metadata %>%
    filter(question_group == question) %>%
    arrange(order)

return(meta_group)
}
```

## Descriptives table

```{r}

create_question_table <- function(data, metadata) {

  all_tables <- list()

  # Ensure metadata$value is numeric (single-select joining fix)
  metadata <- metadata %>%
    mutate(value = suppressWarnings(as.numeric(value)))

  for (question in unique(metadata$question_group)) {

    # Metadata for this question
    meta_group <- metadata %>%
      filter(question_group == question) %>%
      arrange(order)

    q_order <- unique(meta_group$question_order)

    # Get sample size for this question
    sample_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n)

    # MULTI-SELECT QUESTION -----------------------------------------
    if (n_distinct(meta_group$question_code) > 1) {

      option_cols <- meta_group$question_code
      subdata <- data[, option_cols]
      answered <- rowSums(!is.na(subdata)) > 0

      tbl <- subdata %>%
        summarise(across(all_of(option_cols), ~ sum(.x == 1, na.rm = TRUE))) %>%
        pivot_longer(
          cols = everything(),
          names_to = "question_code",
          values_to = "N"
        ) %>%
        left_join(meta_group, by = "question_code") %>%
        mutate(
          Question = question,
          question_order = q_order,
          sample_size = sample_n
        ) %>%
        select(Question, question_order, answer_label, N, sample_size, order)

      all_tables[[question]] <- tbl

    } else {

      # SINGLE-SELECT QUESTION ---------------------------------------
      qcol <- meta_group$question_code[1]
      data[[qcol]] <- suppressWarnings(as.numeric(data[[qcol]]))

      tbl <- meta_group %>%
        select(value, answer_label, order) %>%
        left_join(
          data %>%
            filter(!is.na(.data[[qcol]])) %>%
            group_by(value = .data[[qcol]]) %>%
            summarise(N = n(), .groups = "drop"),
          by = "value"
        ) %>%
        mutate(
          N = replace_na(N, 0),
          Question = question,
          question_order = q_order,
          sample_size = sample_n
        ) %>%
        select(Question, question_order, answer_label, N, sample_size, order)

      all_tables[[question]] <- tbl
    }
  }

  # Bind all rows
  result <- bind_rows(all_tables) %>%
    arrange(question_order, order) %>%
    select(-order)

  # ---- NEW: calculate Percentage at the very end ----
  result <- result %>%
    mutate(
      Percentage = ifelse(
        sample_size == 0, 0, round(N / sample_size * 100, 1))
    ) %>%
    # drop column question_order from dataframe
    select(!question_order)

  result
}




```

## Plotting

For every question, there have to be the following plots:

-   Frequencies overall

-   Frequencies split over neutral/non-neutral

-   Make option in function to split by a specific variable (ideally plotted in the same graph). And make an option to select freqencies or percentages in the function.

-   a/b versions of the same question should also be in combined plots

-   n in the title of the plots

## Specifying function for plots per question

```{r}

plot_question <- function(
    data = data, metadata = meta, question, wrap_width = 60) {
  
  # Extract relevant metadata rows for this question
  meta_group <- metadata %>%
    filter(question_group == question) %>%
    arrange(order)
  
  # Wrap the question text so long titles look clean
  wrapped_title <- stringr::str_wrap(meta_group$item[1], width = wrap_width)

  # --- MULTI-SELECT QUESTIONS (multiple columns in data) ---
  if (n_distinct(meta_group$question_code) > 1) { 
    
    # All answer options that belong to this multi-select question
    all_options <- meta_group %>%
      select(question_code, answer_label, order)
    
    # Count how many respondents selected each option
    # A left join ensures that options with 0 selections still appear
    plot_data <- all_options %>%
      left_join(
        data %>%
          pivot_longer(
            cols = all_of(meta_group$question_code),
            names_to = "question_code",
            values_to = "selected"
          ) %>%
          filter(selected == 1) %>%     # keep only chosen options
          count(question_code),         # count selections
        by = "question_code"
      ) %>%
      mutate(n = replace_na(n, 0))      # ensure missing counts become 0
    
    # Order answer labels according to metadata (not alphabetical)
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label))
    
    # ----- Plot for multi-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = n)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +             # horizontal bars
      scale_y_reverse() +        # bars go right → left
      geom_text(aes(label = n),  # count labels
                hjust = -0.2, size = 3) +
      scale_x_discrete(
        labels = ~ stringr::str_wrap(.x, width = wrap_width),
        position = "top"         # move y-axis labels to the right side
      ) +
      labs(x = NULL, y = "Count", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
    
  } else {
    
    # --- SINGLE-SELECT QUESTIONS (one column in data) ---
    qcol <- meta_group$question_code[1]
    
    # All options available for this question
    all_options <- meta_group %>%
      select(value, answer_label, order)
    
    # Count how many respondents selected each option
    # Left join ensures missing categories appear with 0
    plot_data <- all_options %>%
      left_join(
        data %>%
          filter(!is.na(.data[[qcol]])) %>%       # ignore missing responses
          group_by(value = .data[[qcol]]) %>%     # match metadata$value
          summarise(n = n(), .groups = "drop"),
        by = "value"
      ) %>%
      mutate(n = replace_na(n, 0))
    
    # Keep original answer order
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label))
    
    # ----- Plot for single-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = n)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +
      scale_y_reverse() +
      geom_text(aes(label = n),
                hjust = -0.1, size = 3) +
      scale_x_discrete(
        labels = ~ stringr::str_wrap(.x, width = wrap_width),
        position = "top"
      ) +
      labs(x = NULL, y = "Count", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
  }
}


#plot_question(data, meta, "Q16a")

```

## Plot with percentages (instead of counts)

<!--# This does not work yet. The function has a hard time deciding the number of participants per question. I need the number of participants per question for descriptives too. So maybe start with that tomorrow morning and then incorporate that into this function (or ideally combine the two functions together) -->

```{r}
plot_question_percentage <- function(
    data = data, metadata = meta, question, wrap_width = 60) {
  
  # Extract relevant metadata rows for this question
  meta_group <- metadata %>%
    filter(question_group == question) %>%
    arrange(order)
  
  # Wrap the question text so long titles look clean
  wrapped_title <- stringr::str_wrap(meta_group$item[1], width = wrap_width)

  # --- MULTI-SELECT QUESTIONS (multiple columns in data) ---
  if (n_distinct(meta_group$question_code) > 1) { 
    
    # All answer options that belong to this multi-select question
    all_options <- meta_group %>%
      select(question_code, answer_label, order)
    
    # Count selections per option
    plot_counts <- data %>%
      pivot_longer(
        cols = all_of(meta_group$question_code),
        names_to = "question_code",
        values_to = "selected"
      ) %>%
      filter(selected == 1) %>% 
      count(question_code) 
    
    # Total number of respondents
    total_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n) %>% # pull the column n
      .[1] # take first element from column n

    # Add missing options as 0 + compute percentages
    plot_data <- all_options %>%
      left_join(plot_counts, by = "question_code") %>%
      mutate(
        n = replace_na(n, 0),
        pct = 100 * n / total_n            # percentage
      )

    # Order answer labels according to metadata
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label
        ))
    
    # ----- Plot for multi-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = pct)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +
      scale_y_reverse(limits = c(100, 0)) +        # 0–100% axis always
      geom_text(aes(label = sprintf("%.1f%%", pct)),
                hjust = -0.2, size = 3) +
      scale_x_discrete(labels = ~ stringr::str_wrap(.x, width = wrap_width),
                       position = "top") +
      labs(x = NULL, y = "Percent", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
    
  } else {
    
    # --- SINGLE-SELECT QUESTIONS (one column in data) ---
    qcol <- meta_group$question_code[1]
    
    # All options available for this question
    all_options <- meta_group %>%
      select(value, answer_label, order)
    
    # Count responses per option
    plot_counts <- data %>%
      filter(!is.na(.data[[qcol]])) %>%
      group_by(value = .data[[qcol]]) %>%
      summarise(n = n(), .groups = "drop")
    
    # Total number of respondents
    total_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n) %>% # pull the column n
      .[1] # take first element from column n
    
    # Add missing options + compute percentages
    plot_data <- all_options %>%
      left_join(plot_counts, by = "value") %>%
      mutate(
        n = replace_na(n, 0),
        pct = 100 * n / total_n
      )
    
    # Keep original answer order
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label))
    
    # ----- Plot for single-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = pct)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +
      scale_y_reverse(limits = c(100, 0)) +        # 0–100% axis always
      geom_text(aes(label = sprintf("%.1f%%", pct)),
                hjust = -0.1, size = 3) +
      scale_x_discrete(labels = ~ stringr::str_wrap(.x, width = wrap_width),
                       position = "top") +
      labs(x = NULL, y = "Percent", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
  }
}


```

## Making some plots

```{r}

plot_questions <- c("Q2", "Q3", "Q4", "Q5", "Q6", "Q7a", "Q7b", "Q8", "Q9", "Q10a", "Q10b", "Q11", "Q12", "Q13a", "Q13b", "Q14", "Q15", "Q16a", "Q16b", 
  "Q17", "Q18a", "Q18b", "Q19", "Q20", "Q21", "Q22", "Q23", "Q24", "Q25")

for (i in 1:length(plot_questions)) {
  print(plot_question(data, meta, plot_questions[i]))
  print(plot_question_percentage(data, meta, plot_questions[i]))
}

```
