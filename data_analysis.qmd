---
title: "data_analysis"
format: html
editor: visual
---

<!--# Hey bestie, before submitting the final version -> ctrl + f: 'NOTE' to check if all notes are evaluated and removed -->

## Version Control

```{r}
renv::restore()

library(tidyverse)
library(readxl)
library(ggplot2)
library(stringr)
library(purrr)
library(writexl)
library(openxlsx)
library(forcats)
library(egg)
library(ggpubr)
library(reshape2)
library(lsr)
library(gridExtra)
```

## Loading the data

```{r}

# Load the cleaned data here
load("survey_data_cleaned.RData")

# Load questionnaire metadata
meta <- read.xlsx("question_labels.xlsx", sheet = "codebook")
```

## Sample sizes per question

```{r}

sample_sizes <- meta %>%
  distinct(question_group, question_code) %>%
  arrange(question_group) %>%
  group_by(question_group) %>%
  summarise(
    sample_col = {
      counts <- sapply(question_code, function(col) {
        sum(!is.na(data[[col]]) & data[[col]] != -99 & data[[col]] != 999)
      })
      question_code[which(counts > 0)[1]]
    },
    n = {
      counts <- sapply(question_code, function(col) {
        sum(!is.na(data[[col]]) & data[[col]] != -99 & data[[col]] != 999)
      })
      counts[which(counts > 0)[1]]
    },
    .groups = "drop"
  )

```

## Descriptives table

```{r}

#' Title
#'
#' @param data dataset containing the respondent survey data
#' @param metadata dataset containing metadata about the survey including question numbers, answer categories and variable names.
#' @param sample_sizes a dataframe containing the sample size per question
#'
#' @returns
#'
#' @examples
create_question_table <- function(data, metadata, sample_sizes) {

  all_tables <- list()

  # Ensure metadata$value is numeric so it can be joined later
  metadata <- metadata %>%
    mutate(value = suppressWarnings(as.numeric(value)))
  
  # Loops over every question: question_group is a question (e.g., Q7a)
  for (question in unique(metadata$question_group)) {

    # Metadata for this question
    meta_group <- metadata %>%
      filter(question_group == question) %>% # 'question' is the loop index
      arrange(order)
    
    # Take order index for this question
    q_order <- unique(meta_group$question_order)

    # Get sample size for this question
    sample_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n)

    # MULTI-SELECT QUESTION -----------------------------------------
    if (n_distinct(meta_group$question_code) > 1) { # check if multi-select
      
      # Identify columns in participant data for this question and extract
      option_cols <- meta_group$question_code
      subdata <- data[, option_cols]
      #answered <- rowSums(!is.na(subdata)) > 0 #NOTE: delete line?

      tbl <- subdata %>%
        summarise(across(all_of(option_cols), 
                         ~ sum(.x == 1, na.rm = TRUE))) %>%
        pivot_longer(
          cols = everything(),
          names_to = "question_code",
          values_to = "N"
        ) %>%
        # add metadata (answer labels to data)
        left_join(meta_group, by = "question_code") %>%
        mutate(
          Question = question,
          question_order = q_order,
          sample_size = sample_n
        ) %>%
        select(Question, 
               question_order,
               variable_name,
               answer_label, 
               N, 
               sample_size, 
               order)

      all_tables[[question]] <- tbl
      
    } else {

      # SINGLE-SELECT QUESTION ---------------------------------------
      qcol <- meta_group$question_code[1]
      data[[qcol]] <- suppressWarnings(as.numeric(data[[qcol]]))

      tbl <- meta_group %>%
        select(value, variable_name, answer_label, order) %>%
        left_join(
          data %>%
            filter(!is.na(.data[[qcol]])) %>%
            group_by(value = .data[[qcol]]) %>%
            summarise(N = n(), .groups = "drop"),
          by = "value"
        ) %>%
        mutate(
          N = replace_na(N, 0),
          Question = question,
          question_order = q_order,
          sample_size = sample_n
        ) %>%
        select(Question, 
               question_order,
               variable_name,
               answer_label, 
               N, 
               sample_size, 
               order)

      all_tables[[question]] <- tbl
      
    }
  }

  # Bind all rows
  result <- bind_rows(all_tables) %>%
    arrange(question_order, order) %>%
    select(-order)

  # ---- NEW: calculate Percentage at the very end ----
  result <- result %>%
    mutate(
      Percentage = ifelse(
        sample_size == 0, 0, round(N / sample_size * 100, 1))
    ) %>%
    mutate(
      N_percentage = paste0(N, " (", Percentage, "%)"),
      Variable = paste0(variable_name, " (", Question, ")")
    ) %>%
    # drop column question_order from dataframe
    select(!question_order)

  result
}


descriptives_table <- create_question_table(data, meta, sample_sizes)

```

## Save table for use in paper

```{r}

#write.xlsx(descriptives_table, file = "test_table_desc.xlsx")
```

## Descriptives continues variables

```{r}

vars <- c("Q1", "Q27_1", "Q28_1", "Q29_1")

# Create an empty dataframe to fill
descriptives_continues <- data.frame(
  variable = vars,
  mean = NA_real_,
  sd = NA_real_,
  n = NA_integer_,
  stringsAsFactors = FALSE
)

# Loop through variables and fill the table
for (i in seq_along(vars)) {
  v <- vars[i]
  
  # extract variable and recode -99 and 999 to NA
  x <- data[[v]]
  x[x %in% c(-99, 999)] <- NA
  
  # fill values
  descriptives_continues$mean[i] <- mean(x, na.rm = TRUE)
  descriptives_continues$sd[i]   <- sd(x, na.rm = TRUE)
  descriptives_continues$n[i]    <- sum(!is.na(x))
}

descriptives_continues
  
```

## Correlations

```{r}

vars <- c("Q1", "Q27_1", "Q28_1", "Q29_1")

# Extract only the chosen variables
vars_for_correlations <- data[vars]

# Change missing values to NA (-99 and 999)
vars_for_correlations[vars_for_correlations == -99] <- NA
vars_for_correlations[vars_for_correlations == 999] <- NA

# Compute pairwise correlations using pairwise complete observations
cor_matrix <- cor(vars_for_correlations, use = "pairwise.complete.obs")

#write.xlsx(cor_matrix, "cor_matrix.xlsx")


#################--- Correlation t-tests with finite sample correction ---########################

# Create a matrix of non-missing counts for each pair
n_matrix <- crossprod(!is.na(vars_for_correlations))

# Calculate t-values for the whole matrix
# This applies your FPC formula to every cell
t_matrix <- (cor_matrix - rho) / (sqrt((1 - cor_matrix^2) / (n_matrix - 2)) * sqrt((N - n_matrix) / (N - 1)))

# Calculate p-values
# df is also a matrix here (n - 2)
p_matrix <- 2 * (1 - pt(abs(t_matrix), df = n_matrix - 2))

# Clean up diagonals
diag(p_matrix) <- NA
diag(t_matrix) <- NA

# Combine into a single data frame
results <- data.frame(
  Pair = melt(cor_matrix)$Var1,
  Var2 = melt(cor_matrix)$Var2,
  Correlation = melt(cor_matrix)$value,
  t_stat = melt(t_matrix)$value,
  p_val = melt(p_matrix)$value,
  n = melt(n_matrix)$value
)

results <- results %>%
  mutate(df = n - 2)

# Filter out duplicates (the lower triangle of the matrix)
results <- results[as.numeric(results$Pair) < as.numeric(results$Var2), ]


### Scatterplots
# NOTE: would need to put names in the plot for clarity
pairs(~Q27_1 + Q28_1 + Q29_1, data = data, xlim = c(0,1), ylim = c(0,1))


```

## Plotting

For every question, there have to be the following plots:

-   Frequencies overall

-   Frequencies split over neutral/non-neutral

-   Make option in function to split by a specific variable (ideally plotted in the same graph). And make an option to select freqencies or percentages in the function.

-   a/b versions of the same question should also be in combined plots

-   n in the title of the plots

## One combined function for all plots

```{r}
plot_combined_questions <- function(
  data,
  metadata,
  sample_sizes,
  combined_questions,
  legend_labels = c("Conditions", "Methods", "Performance Measures"),
  title_plot = combined_questions,
  combine_ab = FALSE,
  wrap_width = 50,
  colors = c("#0072B2", "#D55E00", "#F0E442"),
  y_max = 100,
  show_legend = length(combined_questions) > 1
) {

  # ---- 1. Select & (optionally) map a/b versions ----
  if (combine_ab) {
    question_map <- tibble(
      combined = rep(combined_questions, each = 2),
      question_group = paste0(rep(combined_questions, each = 2), c("a", "b"))
    )
    
    meta_sel <- metadata %>%
      inner_join(question_map, by = "question_group") %>%
      arrange(combined, order)
  } else {
    
    meta_sel <- metadata %>%
      filter(question_group %in% combined_questions) %>%
      mutate(combined = question_group) %>%
      arrange(combined, order)
  }

  # ---- 2. Use the external sample_sizes object ----
  # We filter the master sample_sizes for the questions we are plotting
  # If it's an 'ab' combined question, we sum the n's.
  if (combine_ab) {
    plot_sample_sizes <- sample_sizes %>%
      inner_join(question_map, by = "question_group") %>%
      group_by(combined) %>%
      summarise(sample_size = sum(n), .groups = "drop")
  } else {
    plot_sample_sizes <- sample_sizes %>%
      filter(question_group %in% combined_questions) %>%
      rename(combined = question_group, sample_size = n) %>%
      select(combined, sample_size)
  }
  
  # ---- 3. Count selections ----
  long_data <- data %>%
    pivot_longer(
      cols = unique(meta_sel$question_code),
      names_to = "question_code",
      values_to = "value"
    )

  if (combine_ab) {
    long_data <- long_data %>% filter(value == 1)
  } else {
    long_data <- long_data %>% filter(!is.na(value))
  }

  counts <- meta_sel %>%
    select(combined, question_code, short_label, order, value) %>%
    left_join(
      long_data %>%
        count(question_code, value, name = "freq"),
      by = c("question_code", "value")
    ) %>%
    mutate(freq = replace_na(freq, 0)) %>%
    group_by(combined, short_label, order) %>%
    summarise(freq = sum(freq), .groups = "drop")

  # ---- 4. Percentages & factors ----
  plot_data <- counts %>%
    left_join(plot_sample_sizes, by = "combined") %>% # Joining pre-calculated sizes
    mutate(
      pct = 100 * freq / sample_size,
      label = sprintf("%.1f%% (%d)", pct, freq),
      combined = factor(combined, levels = combined_questions),
      short_label = factor(
        short_label,
        levels = meta_sel %>%
          arrange(order) %>%
          distinct(short_label) %>%
          pull(short_label)
      )
    )

  # ---- 5. Plot ----
  ggplot(
    plot_data,
    aes(
      x = fct_rev(short_label),
      y = pct,
      fill = combined
    )
  ) +
    geom_col(
      position = position_dodge(width = 0.8),
      width = 0.8,
      alpha = 0.8,
      color = "black",
      linewidth = 0.3
    ) +
    geom_text(
      aes(label = label),
      position = position_dodge(width = 0.8),
      hjust = -0.05,
      size = 3.5
    ) +
    coord_flip() +
    scale_y_continuous(
      limits = c(0, y_max),
      expand = expansion(mult = c(0, 0.1))
    ) +
    scale_fill_manual(
      values = setNames(colors, combined_questions),
      labels = setNames(legend_labels, combined_questions),
      name = ""
    ) +
    scale_x_discrete(
      labels = ~ stringr::str_wrap(.x, wrap_width)
    ) +
    labs(
      x = NULL,
      y = "Percentage",
      title = if (!is.null(title_plot)) stringr::str_wrap(title_plot, wrap_width)
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
      axis.title.x = element_text(size = 8),
      axis.text.y = element_text(hjust = 1, size = 9),
      legend.position = if (show_legend) "right" else "none"
    )
}

```

## All Plots

```{r}

# Plot for question 7, 10, and 13
# NOTE: this plot is genereted later??
p7_10_13 <- plot_combined_questions(data,
                               meta,
                               combined_questions = c("Q7", "Q10", "Q13"),
                               sample_sizes = sample_sizes,
                               combine_ab = TRUE,
                               title_plot = "Results weren't reported for all [Legend] because...",
                               y_max = 100,
                               wrap_width = 80)


# Topic 2.4: Missing values/nonconvergence
p16 <- plot_combined_questions(data,
                               meta,
                               combined_questions = "Q16",
                               sample_sizes = sample_sizes,
                               combine_ab = TRUE,
                               colors = "#D55E00",
                               title_plot = "The number of missing values/nonconvergent iterations wasn't reported because...",
                               y_max = 75,
                               wrap_width = 60)

# Topic 2.5: MCSE
p18 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q18",
                        sample_sizes = sample_sizes,
                        combine_ab = TRUE, 
                        colors = "#D55E00",
                        title_plot = "MCSE's weren't reported (for all results) because...",
                        y_max = 75,
                        wrap_width = 80) 

# Topic 2.6: Guidelines
p20 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q20",
                        sample_sizes = sample_sizes,
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Why was no research guideline used?",
                        y_max = 100,
                        wrap_width = 80)

# Topic 2.7: Preregistration
p22 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q22",
                        sample_sizes = sample_sizes,
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Why wasn't the simulation study preregistered?",
                        y_max = 100,
                        wrap_width = 80) 

# Topic 2.8: Open code
p24 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q24",
                        sample_sizes = sample_sizes,
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Why is not all code openly available?",
                        y_max = 100,
                        wrap_width = 80)

# Topic 2.9: Open code
p25 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q25",
                        sample_sizes = sample_sizes,
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Which measures were taken for computational reproducibility?",
                        y_max = 100,
                        wrap_width = 40)

p20 <- p20 + theme(plot.margin = margin(10, 10, 10, 30))
p24 <- p24 + theme(plot.margin = margin(10, 10, 10, 30))
p22 <- p22 + theme(plot.margin = margin(10, 10, 10, 30))
p25 <- p25 + theme(plot.margin = margin(10, 10, 10, 30))
p16 <- p16 + theme(plot.margin = margin(10, 10, 10, 30))
p18 <- p18 + theme(plot.margin = margin(10, 10, 10, 30))

ggarrange(p20, p24, p22, p25, nrow = 4, ncol = 1)
ggarrange(p16, p18, nrow = 2, ncol = 1)

# Saving plots in high quality
#ggsave("plot.png", plot = p20)

```

## Combined Plot Reporting

```{r}

# NOTE: check if this is the right place to add these variables to the data
data <- data %>%
  mutate(conditions = ifelse(is.na(Q6) & Q5 == 2, 0, Q6),
         methods = ifelse(is.na(Q9) & Q8 == 2, 0, Q9),
         perfmeas = ifelse(is.na(Q12) & Q11 == 2, 0, Q12)) %>%
  mutate(conditions = ifelse(conditions == -99, NA_real_, conditions),
         methods = ifelse(methods == -99, NA_real_, methods),
         perfmeas = ifelse(perfmeas == -99, NA_real_, perfmeas))


pconditions <- plot_combined_questions(data = data,
                               meta,
                               sample_sizes = sample_sizes,
                               combined_questions = c("conditions", "methods", "perfmeas"),
                               combine_ab = FALSE,
                               title_plot = "Is at least one result reported for every condition/method/performance measure that was part of the simulations?",
                               y_max = 100,
                               wrap_width = 80)


## How many participants engaged in not reporting a result for any of the elements?
data_not_reported <- data %>%
  filter(conditions == 0 | methods == 0 | perfmeas == 0)

any_not_reported <- nrow(data_not_reported)/221

## How many participants engaged in split reporting a results for any of the elements?
data_split_reported <- data %>%
  filter(conditions == 2 | methods == 2 | perfmeas == 2)

any_split_reported <- nrow(data_split_reported)/221

total_any_selective_reported <- (nrow(data_not_reported) + nrow(data_split_reported))/221


# NOTE: check if we keep this or not
## How many participants engaged in either focusing on significant results (6), conclusion alignment (8), or a specific method (10)
# conditions = 19.0%
qrp_condition <- data %>%
  filter(Q7a_6 == 1 |
         Q7b_6 == 1 |
           Q7a_8 == 1 |
           Q7b_8 == 1 |
           Q7a_10 == 1 |
           Q7b_10 == 1 )

# methods = 22.6%
qrp_method <- data %>%
  filter(Q10a_6 == 1 |
         Q10b_6 == 1 |
           Q10a_8 == 1 |
           Q10b_8 == 1 |
           Q10a_10 == 1 |
           Q10b_10 == 1 )


# performance measures = 27.2%
qrp_pm <- data %>%
  filter(Q13a_6 == 1 |
         Q13b_6 == 1 |
           Q13a_8 == 1 |
           Q13b_8 == 1 |
           Q13a_10 == 1 |
           Q13b_10 == 1 )


```

## Plots split by variable

```{r}

plot_combined_questions_grouped <- function(
  data,
  metadata,
  combined_questions,
  split_var = NULL,
  legend_labels = c("Neutral", "Developer"), 
  title_plot = combined_questions,
  combine_ab = FALSE,
  wrap_width = 50,
  colors = c("#0072B2", "#D55E00"), 
  y_max = 100,
  show_legend = TRUE
) {

  # ---- 1. Select & Map Metadata ----
  if (combine_ab) {
    question_map <- tibble(
      combined = rep(combined_questions, each = 2),
      question_group = paste0(rep(combined_questions, each = 2), c("a", "b"))
    )
    
    meta_sel <- metadata %>%
      inner_join(question_map, by = "question_group") %>%
      arrange(combined, order)
    
  } else {
    
    meta_sel <- metadata %>%
      filter(question_group %in% combined_questions) %>%
      mutate(combined = question_group) %>%
      arrange(combined, order)
  }

  # ---- 2. Calculate Sample Sizes per Group ----
  plot_sample_sizes <- meta_sel %>%
    distinct(combined, question_group, question_code) %>%
    group_by(combined, question_group) %>%
    group_modify(~ {
      current_code <- .x$question_code[1]
      data %>%
        # Ensure split_var is a factor here
        mutate(across(all_of(split_var), as.factor)) %>% 
        group_by(across(all_of(split_var))) %>%
        summarise(
          sample_size = sum(!is.na(.data[[current_code]]) & 
                            .data[[current_code]] != -99 & 
                            .data[[current_code]] != 999),
          .groups = "drop"
        )
    }) %>%
    ungroup()

  if (combine_ab) {
    plot_sample_sizes <- plot_sample_sizes %>%
      group_by(across(all_of(c(split_var, "combined")))) %>%
      summarise(sample_size = sum(sample_size), .groups = "drop")
  } else {
    plot_sample_sizes <- plot_sample_sizes %>%
      select(all_of(c(split_var, "combined", "sample_size")))
  }

  # ---- 3. Count Selections ----
  relevant_codes <- unique(meta_sel$question_code)
  long_data <- data %>%
    select(all_of(c(split_var, relevant_codes))) %>%
    # Ensure split_var is a factor here as well
    mutate(across(all_of(split_var), as.factor)) %>%
    pivot_longer(
      cols = all_of(relevant_codes),
      names_to = "question_code",
      values_to = "value"
    )

  if (combine_ab) {
    long_data <- long_data %>% filter(value == 1)
  } else {
    long_data <- long_data %>% filter(!is.na(value))
  }

  counts <- long_data %>%
    inner_join(meta_sel, by = c("question_code", "value")) %>%
    group_by(across(all_of(c(split_var, "combined", "short_label", "order")))) %>%
    summarise(freq = n(), .groups = "drop")

  # ---- 4. Percentages & Factors ----
  plot_data <- counts %>%
    complete(
      nesting(combined, short_label, order), 
      !!sym(split_var), 
      fill = list(freq = 0)
    ) %>%
    left_join(plot_sample_sizes, by = c(split_var, "combined")) %>%
    mutate(
      pct = ifelse(is.na(sample_size) | sample_size == 0, 0, 100 * freq / sample_size),
      label = sprintf("%.1f%% (%d)", pct, freq),
      short_label = factor(
        short_label, 
        levels = meta_sel %>% arrange(order) %>% distinct(short_label) %>% pull(short_label)
      )
    )

  # ---- 5. Plot ----
  # NOTE: clear this mess up:
  ggplot(plot_data, aes(x = fct_rev(short_label), y = pct, fill = .data[[split_var]])) +
    geom_col(position = position_dodge(width = 0.8), width = 0.8, alpha = 0.8, color = "black", linewidth = 0.3) +
    geom_text(aes(label = label), position = position_dodge(width = 0.8), hjust = -0.1, size = 3) +
    coord_flip() +
    scale_y_continuous(limits = c(0, y_max), expand = expansion(mult = c(0, 0.2))) +
    scale_fill_manual(values = colors, labels = legend_labels, name = "") +
    scale_x_discrete(labels = ~ stringr::str_wrap(.x, wrap_width)) +
    labs(x = NULL, y = "Percentage", title = if (!is.null(title_plot)) stringr::str_wrap(title_plot, wrap_width)) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5, size = 10, face = "bold"),
          axis.text.y = element_text(face = "bold"),
          legend.position = "bottom", plot.margin = margin(10, 10, 10, 30))
}
```

## Plot a question

-   NOTE: Check if Q14 and Q15 should also become a combined plot, then add new variable just as with conditions/methods/performance measures

```{r}
# Generating a PDF with plots split by new_method
# NOTE: titles need to be added correctly

vars_to_plot_ab <- c("Q7", "Q10", "Q13", "Q16", "Q18")

all_vars <- c("conditions", "Q7", "methods", "Q10", "perfmeas", "Q13", "Q14", "Q15", "Q16", "Q17", "Q18", "Q19", "Q20", "Q21", "Q22", "Q23", "Q24", "Q25")

plot_list <- list()

for (i in 1:length(all_vars)) {
  
  # Extract the title from metadata for the current question
  current_title <- meta %>%
    filter(question_group == all_vars[i]) %>%
    slice(1) %>%
    pull(item)
  
  # Call the function using the extracted title
  p <- plot_combined_questions_grouped(
    data = data,
    metadata = meta,
    combine_ab = all_vars[i] %in% vars_to_plot_ab,
    combined_questions = all_vars[i],
    split_var = "new_method",
    wrap_width = 50,
    title_plot = paste0(all_vars[i], ": ", current_title)
  )
  plot_list[[i]] <- p + theme(plot.margin = margin(1, 1, 1, 1, "cm"))
}

# Add plots to object to save
multipage_plot <- marrangeGrob(plot_list, nrow = 2, ncol = 2) # NOTE: Check how many plots per page works well
# Generate PDF with plots
ggsave("Questionnaire_Results_Full.pdf", multipage_plot, width = 8.5, height = 11)


########## Plots split by aim ##################
# NOTE: not done yet

plot_combined_questions_grouped(
    data = data,
    metadata = meta,
    combine_ab = FALSE,
    combined_questions = c("Q12"),
    colors = c("red", "blue", "grey", "orange"),
    split_var = "Q2" #split by aim
)
```

## Calculating Fisher's Exact test, Chi\^2, and Cramer's V for split by new_method

1.  Get dataframe as input for both the plots and the calculations

```{r}
# NOTE: change name of plot-data. because it is not used to plot anymore
get_plot_data <- function(data, metadata, combined_questions, split_var, combine_ab = FALSE) {
  
  # ---- 1. Select & Map Metadata ----
  if (combine_ab) {
    question_map <- tibble(
      combined = rep(combined_questions, each = 2),
      question_group = paste0(rep(combined_questions, each = 2), c("a", "b"))
    )
    meta_sel <- metadata %>%
      inner_join(question_map, by = "question_group") %>%
      arrange(combined, order)
  } else {
    meta_sel <- metadata %>%
      filter(question_group %in% combined_questions) %>%
      mutate(combined = question_group) %>%
      arrange(combined, order)
  }

  # ---- 2. Calculate Sample Sizes per Group ----
  plot_sample_sizes <- meta_sel %>%
    distinct(combined, question_group, question_code) %>%
    group_by(combined, question_group) %>%
    group_modify(~ {
      current_code <- .x$question_code[1]
      data %>%
        # Ensure split_var is a factor here
        mutate(across(all_of(split_var), as.factor)) %>% 
        group_by(across(all_of(split_var))) %>%
        summarise(
          sample_size = sum(!is.na(.data[[current_code]]) & 
                            .data[[current_code]] != -99 & 
                            .data[[current_code]] != 999),
          .groups = "drop"
        )
    }) %>%
    ungroup()

  if (combine_ab) {
    plot_sample_sizes <- plot_sample_sizes %>%
      group_by(across(all_of(c(split_var, "combined")))) %>%
      summarise(sample_size = sum(sample_size), .groups = "drop")
  } else {
    plot_sample_sizes <- plot_sample_sizes %>%
      select(all_of(c(split_var, "combined", "sample_size")))
  }

  # ---- 3. Count Selections ----
  relevant_codes <- unique(meta_sel$question_code)
  long_data <- data %>%
    select(all_of(c(split_var, relevant_codes))) %>%
    # Ensure split_var is a factor here as well
    mutate(across(all_of(split_var), as.factor)) %>%
    pivot_longer(
      cols = all_of(relevant_codes),
      names_to = "question_code",
      values_to = "value"
    )

  if (combine_ab) {
    long_data <- long_data %>% filter(value == 1)
  } else {
    long_data <- long_data %>% filter(!is.na(value))
  }

  counts <- long_data %>%
    inner_join(meta_sel, by = c("question_code", "value")) %>%
    group_by(across(all_of(c(split_var, "combined", "short_label", "order")))) %>%
    summarise(freq = n(), .groups = "drop")

  # ---- 4. Percentages & Factors ----
  plot_data <- counts %>%
    complete(
      nesting(combined, short_label, order), 
      !!sym(split_var), 
      fill = list(freq = 0)
    ) %>%
    left_join(plot_sample_sizes, by = c(split_var, "combined")) %>%
    mutate(
      pct = ifelse(is.na(sample_size) | sample_size == 0, 0, 100 * freq / sample_size),
      label = sprintf("%.1f%% (%d)", pct, freq),
      short_label = factor(
        short_label, 
        levels = meta_sel %>% arrange(order) %>% distinct(short_label) %>% pull(short_label)
      )
    )
  
  return(plot_data)
}
```

Apply function to generate the dataframe for new_method

```{r}

# Run the get plot data function to generate the dataframe
plot_data_1 <- get_plot_data(data = data, metadata = meta, combined_questions = vars_to_plot_ab, split_var = "new_method", combine_ab = TRUE)

plot_data_2 <- get_plot_data(data = data, metadata = meta, combined_questions = vars_to_plot_regular, split_var = "new_method", combine_ab = FALSE)

plot_data <- rbind(plot_data_1, plot_data_2)

```

2.  Take the processed plot_data and run the tests

```{r}

calculate_stats_by_question <- function(plot_df, split_var) {
  
  # 1. Identify the different questions (e.g., Q10 and Q13)
  questions <- unique(plot_df$combined)
  
  results_list <- list()
  
  for (q in questions) {
    # Filter data for just this question
    q_data <- plot_df %>% filter(combined == q)
    
    # 2. Create the Contingency Table for this question specifically
    # Rows: Answer Labels, Cols: Group (0/1)
    test_table <- q_data %>%
      select(short_label, all_of(split_var), freq) %>%
      pivot_wider(names_from = all_of(split_var), values_from = freq) %>%
      # Replace NAs with 0 if some groups didn't select an answer
      mutate(across(everything(), ~replace_na(., 0))) %>%
      column_to_rownames("short_label") %>%
      as.matrix()
    
    # 3. Run Fisher's Exact Test (Recommended for your small N)
    # Note: simulate.p.value = TRUE is helpful for tables larger than 2x2
    fisher_res <- fisher.test(test_table, simulate.p.value = TRUE)
    
    # 4. Optional: Run Chi-Square (will likely show "Chi-squared approximation may be incorrect")
    chi_res <- chisq.test(test_table)
    cv_res  <- lsr::cramersV(test_table)
    
    # Store results for this question
    results_list[[q]] <- list(
      question = q,
      table = test_table,
      fisher_p = fisher_res$p.value,
      chi_sq = chi_res$statistic,
      chi_p = chi_res$p.value,
      cramers_v = cv_res
    )
  }
  
  return(results_list)
}

# To use it:
all_results <- calculate_stats_by_question(plot_data, "new_method")

summary_stats <- do.call(rbind, lapply(all_results, function(x) {
  data.frame(
    Question = x$question,
    Fisher_P = round(x$fisher_p, 4),
    Chi_Sq = round(x$chi_sq, 2),
    Chi_P = round(x$chi_p, 4),
    Cramers_V = round(x$cramers_v, 3),
    Significance = ifelse(x$fisher_p < 0.05, "Yes*", "No")
  )
}))
```
