---
title: "data_analysis"
format: html
editor: visual
---

## Version Control

```{r}
renv::restore()

library(tidyverse)
library(readxl)
library(ggplot2)
library(stringr)
library(purrr)
library(writexl)
library(openxlsx)
library(forcats)
library(egg)
library(ggpubr)
```

## Loading the data

```{r}

# Load the cleaned data here
load("survey_data_cleaned.RData")

# Load questionnaire metadata
meta <- read.xlsx("question_labels.xlsx", sheet = "codebook")
```

## Descriptives

-   

```{r}

sample_sizes <- meta %>%
  distinct(question_group, question_code) %>%
  arrange(question_group) %>%
  group_by(question_group) %>%
  summarise(
    sample_col = first(question_code),
    n = sum(!is.na(data[[sample_col]])),
    .groups = "drop"
  )

# Function to get answer options per question (NOTE: not needed anymore)
get_question_columns <- function(metadata = meta, question) {
meta_group <- metadata %>%
    filter(question_group == question) %>%
    arrange(order)

return(meta_group)
}
```

## Descriptives table

-   New method variable is not added correctly yet

```{r}

#' Title
#'
#' @param data dataset containing the respondent survey data
#' @param metadata dataset containing metadata about the survey including question numbers, answer categories and variable names.
#' @param sample_sizes a dataframe containing the sample size per question
#'
#' @returns
#'
#' @examples
create_question_table <- function(data, metadata, sample_sizes) {

  all_tables <- list()

  # Ensure metadata$value is numeric so it can be joined later
  metadata <- metadata %>%
    mutate(value = suppressWarnings(as.numeric(value)))
  
  # Loops over every question: question_group is a question (e.g., Q7a)
  for (question in unique(metadata$question_group)) {

    # Metadata for this question
    meta_group <- metadata %>%
      filter(question_group == question) %>% # 'question' is the loop index
      arrange(order)
    
    # Take order index for this question
    q_order <- unique(meta_group$question_order)

    # Get sample size for this question
    sample_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n)

    # MULTI-SELECT QUESTION -----------------------------------------
    if (n_distinct(meta_group$question_code) > 1) { # check if multi-select
      
      # Identify columns in participant data for this question and extract
      option_cols <- meta_group$question_code
      subdata <- data[, option_cols]
      #answered <- rowSums(!is.na(subdata)) > 0 #NOTE: delete line?

      tbl <- subdata %>%
        summarise(across(all_of(option_cols), 
                         ~ sum(.x == 1, na.rm = TRUE))) %>%
        pivot_longer(
          cols = everything(),
          names_to = "question_code",
          values_to = "N"
        ) %>%
        # add metadata (answer labels to data)
        left_join(meta_group, by = "question_code") %>%
        mutate(
          Question = question,
          question_order = q_order,
          sample_size = sample_n
        ) %>%
        select(Question, 
               question_order,
               variable_name,
               answer_label, 
               N, 
               sample_size, 
               order)

      all_tables[[question]] <- tbl
      
    } else {

      # SINGLE-SELECT QUESTION ---------------------------------------
      qcol <- meta_group$question_code[1]
      data[[qcol]] <- suppressWarnings(as.numeric(data[[qcol]]))

      tbl <- meta_group %>%
        select(value, variable_name, answer_label, order) %>%
        left_join(
          data %>%
            filter(!is.na(.data[[qcol]])) %>%
            group_by(value = .data[[qcol]]) %>%
            summarise(N = n(), .groups = "drop"),
          by = "value"
        ) %>%
        mutate(
          N = replace_na(N, 0),
          Question = question,
          question_order = q_order,
          sample_size = sample_n
        ) %>%
        select(Question, 
               question_order,
               variable_name,
               answer_label, 
               N, 
               sample_size, 
               order)

      all_tables[[question]] <- tbl
      
    }
  }

  # Bind all rows
  result <- bind_rows(all_tables) %>%
    arrange(question_order, order) %>%
    select(-order)

  # ---- NEW: calculate Percentage at the very end ----
  result <- result %>%
    mutate(
      Percentage = ifelse(
        sample_size == 0, 0, round(N / sample_size * 100, 1))
    ) %>%
    mutate(
      N_percentage = paste0(N, " (", Percentage, "%)")
    ) %>%
    # drop column question_order from dataframe
    select(!question_order)

  result
}


descriptives_table <- create_question_table(data, meta, sample_sizes)

```

## Save table for use in paper

```{r}

#write.xlsx(descriptives_table, file = "test_table_desc.xlsx")
```

## Descriptives continues variables

```{r}

vars <- c("Q1", "Q27_1", "Q28_1", "Q29_1")

# Create an empty dataframe to fill
descriptives_continues <- data.frame(
  variable = vars,
  mean = NA_real_,
  sd = NA_real_,
  n = NA_integer_,
  stringsAsFactors = FALSE
)

# Loop through variables and fill the table
for (i in seq_along(vars)) {
  v <- vars[i]
  
  # extract variable and recode -99 and 999 to NA
  x <- data[[v]]
  x[x %in% c(-99, 999)] <- NA
  
  # fill values
  descriptives_continues$mean[i] <- mean(x, na.rm = TRUE)
  descriptives_continues$sd[i]   <- sd(x, na.rm = TRUE)
  descriptives_continues$n[i]    <- sum(!is.na(x))
}

descriptives_continues
  
```

## Correlations

```{r}

vars <- c("Q1", "Q27_1", "Q28_1", "Q29_1")

# Extract only the chosen variables
vars_for_correlations <- data[vars]

# Change missing values to NA (-99 and 999)
vars_for_correlations[vars_for_correlations == -99] <- NA
vars_for_correlations[vars_for_correlations == 999] <- NA

# Compute pairwise correlations using pairwise complete observations
cor_matrix <- cor(vars_for_correlations, use = "pairwise.complete.obs")

cor_matrix

#write.xlsx(cor_matrix, "cor_matrix.xlsx")


 # ----------- NOTE: not done yet here: --------- #

# Calculating the t-statistic with the finite population correction factor
r <- 0.3341475
rho <- 0
n <- 196
N <- 949 # Number of included articles (= population size)

t_corrected <- function(r, rho, n, N) {
  t <- (r - rho)/(sqrt((1-r^2)/(n - 2))*sqrt((N-n)/(N-1)))
  return(t)
}

# two-sided t-test
p_value <- function(t_value, df) { 2 * (1 - pt(abs(t_value), df)) }


# Run the t-test
t_value <- t_corrected(r, rho, n, N)
p <- p_value(t_value, df = n - 2)

```

## Plotting

For every question, there have to be the following plots:

-   Frequencies overall

-   Frequencies split over neutral/non-neutral

-   Make option in function to split by a specific variable (ideally plotted in the same graph). And make an option to select freqencies or percentages in the function.

-   a/b versions of the same question should also be in combined plots

-   n in the title of the plots

## Specifying function for plots per question (DELETE)

```{r}

plot_question <- function(
    data = data, metadata = meta, question, wrap_width = 60) {
  
  # Extract relevant metadata rows for this question
  meta_group <- metadata %>%
    filter(question_group == question) %>%
    arrange(order)
  
  # Wrap the question text so long titles look clean
  wrapped_title <- stringr::str_wrap(meta_group$item[1], width = wrap_width)

  # --- MULTI-SELECT QUESTIONS (multiple columns in data) ---
  if (n_distinct(meta_group$question_code) > 1) { 
    
    # All answer options that belong to this multi-select question
    all_options <- meta_group %>%
      select(question_code, answer_label, order)
    
    # Count how many respondents selected each option
    # A left join ensures that options with 0 selections still appear
    plot_data <- all_options %>%
      left_join(
        data %>%
          pivot_longer(
            cols = all_of(meta_group$question_code),
            names_to = "question_code",
            values_to = "selected"
          ) %>%
          filter(selected == 1) %>%     # keep only chosen options
          count(question_code),         # count selections
        by = "question_code"
      ) %>%
      mutate(n = replace_na(n, 0))      # ensure missing counts become 0
    
    # Order answer labels according to metadata (not alphabetical)
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label))
    
    # ----- Plot for multi-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = n)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +             # horizontal bars
      scale_y_reverse() +        # bars go right → left
      geom_text(aes(label = n),  # count labels
                hjust = -0.2, size = 3) +
      scale_x_discrete(
        labels = ~ stringr::str_wrap(.x, width = wrap_width),
        position = "top"         # move y-axis labels to the right side
      ) +
      labs(x = NULL, y = "Count", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
    
  } else {
    
    # --- SINGLE-SELECT QUESTIONS (one column in data) ---
    qcol <- meta_group$question_code[1]
    
    # All options available for this question
    all_options <- meta_group %>%
      select(value, answer_label, order)
    
    # Count how many respondents selected each option
    # Left join ensures missing categories appear with 0
    plot_data <- all_options %>%
      left_join(
        data %>%
          filter(!is.na(.data[[qcol]])) %>%       # ignore missing responses
          group_by(value = .data[[qcol]]) %>%     # match metadata$value
          summarise(n = n(), .groups = "drop"),
        by = "value"
      ) %>%
      mutate(n = replace_na(n, 0))
    
    # Keep original answer order
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label))
    
    # ----- Plot for single-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = n)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +
      scale_y_reverse() +
      geom_text(aes(label = n),
                hjust = -0.1, size = 3) +
      scale_x_discrete(
        labels = ~ stringr::str_wrap(.x, width = wrap_width),
        position = "top"
      ) +
      labs(x = NULL, y = "Count", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
  }
}


#plot_question(data, meta, "Q16a")

```

## Plot with percentages (instead of counts) (DELETE)

```{r}
plot_question_percentage <- function(
    data = data, metadata = meta, question, wrap_width = 60) {
  
  # Extract relevant metadata rows for this question
  meta_group <- metadata %>%
    filter(question_group == question) %>%
    arrange(order)
  
  # Wrap the question text so long titles look clean
  wrapped_title <- stringr::str_wrap(meta_group$item[1], width = wrap_width)

  # --- MULTI-SELECT QUESTIONS (multiple columns in data) ---
  if (n_distinct(meta_group$question_code) > 1) { 
    
    # All answer options that belong to this multi-select question
    all_options <- meta_group %>%
      select(question_code, answer_label, order)
    
    # Count selections per option
    plot_counts <- data %>%
      pivot_longer(
        cols = all_of(meta_group$question_code),
        names_to = "question_code",
        values_to = "selected"
      ) %>%
      filter(selected == 1) %>% 
      count(question_code) 
    
    # Total number of respondents
    total_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n) %>% # pull the column n
      .[1] # take first element from column n

    # Add missing options as 0 + compute percentages
    plot_data <- all_options %>%
      left_join(plot_counts, by = "question_code") %>%
      mutate(
        n = replace_na(n, 0),
        pct = 100 * n / total_n            # percentage
      )

    # Order answer labels according to metadata
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label
        ))
    
    # ----- Plot for multi-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = pct)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +
      scale_y_reverse(limits = c(100, 0)) +        # 0–100% axis always
      geom_text(aes(label = sprintf("%.1f%%", pct)),
                hjust = -0.2, size = 3) +
      scale_x_discrete(labels = ~ stringr::str_wrap(.x, width = wrap_width),
                       position = "top") +
      labs(x = NULL, y = "Percent", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
    
  } else {
    
    # --- SINGLE-SELECT QUESTIONS (one column in data) ---
    qcol <- meta_group$question_code[1]
    
    # All options available for this question
    all_options <- meta_group %>%
      select(value, answer_label, order)
    
    # Count responses per option
    plot_counts <- data %>%
      filter(!is.na(.data[[qcol]])) %>%
      group_by(value = .data[[qcol]]) %>%
      summarise(n = n(), .groups = "drop")
    
    # Total number of respondents
    total_n <- sample_sizes %>%
      filter(question_group == question) %>%
      pull(n) %>% # pull the column n
      .[1] # take first element from column n
    
    # Add missing options + compute percentages
    plot_data <- all_options %>%
      left_join(plot_counts, by = "value") %>%
      mutate(
        n = replace_na(n, 0),
        pct = 100 * n / total_n
      )
    
    # Keep original answer order
    plot_data <- plot_data %>%
      mutate(answer_label = factor(
        answer_label, levels = meta_group$answer_label))
    
    # ----- Plot for single-select -----
    ggplot(plot_data, 
           aes(x = fct_reorder(answer_label, desc(order)), 
               y = pct)) +
      geom_col(fill = "#f68060", alpha = 0.6, width = 0.4) +
      coord_flip() +
      scale_y_reverse(limits = c(100, 0)) +        # 0–100% axis always
      geom_text(aes(label = sprintf("%.1f%%", pct)),
                hjust = -0.1, size = 3) +
      scale_x_discrete(labels = ~ stringr::str_wrap(.x, width = wrap_width),
                       position = "top") +
      labs(x = NULL, y = "Percent", title = wrapped_title) +
      theme_bw() +
      theme(
        axis.text.y = element_text(angle = 0, hjust = 1),
        plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.margin = margin(t = 20, r = 10, b = 10, l = 10, unit = "pt")
      )
  }
}


```

## Making some plots (DELETE)

```{r}

plot_questions <- c("Q2", "Q3", "Q4", "Q5", "Q6", "Q7a", "Q7b", "Q8", "Q9", "Q10a", "Q10b", "Q11", "Q12", "Q13a", "Q13b", "Q14", "Q15", "Q16a", "Q16b", 
  "Q17", "Q18a", "Q18b", "Q19", "Q20", "Q21", "Q22", "Q23", "Q24", "Q25")

for (i in 1:length(plot_questions)) {
  print(plot_question(data, meta, plot_questions[i]))
  print(plot_question_percentage(data, meta, plot_questions[i]))
}

```

## Combined question plot (DELETE???? Check eerst of de nieuwe functie ook hiervoor goed werkt)

-   freq van 0 wordt niet met tekst weergegeven

-   freq van 1 wordt afgesneden

-   Volgorde bars komt niet overeen met legenda

-   Sample size per vraag nog toevoegen (in de legenda)?

```{r}

plot_combined_multiselect <- function(
  data = data,
  metadata = meta,
  combined_questions = c("Q7", "Q10", "Q13"),
  wrap_width = 50
) {

  # ---- 1. Map combined → a/b versions ----
  question_map <- tibble(
    combined = rep(combined_questions, each = 2),
    question_group = paste0(rep(combined_questions, each = 2), c("a", "b"))
  )

  meta_sel <- metadata %>%
    inner_join(question_map, by = "question_group") %>%
    arrange(combined, order)

  # ---- 2. Compute sample sizes per a/b version ----
  sample_sizes_ab <- meta_sel %>%
    distinct(combined, question_group, question_code) %>%
    group_by(combined, question_group) %>%
    summarise(
      n = sum(rowSums(!is.na(data[question_code])) > 0),
      .groups = "drop"
    )

  sample_sizes <- sample_sizes_ab %>%
    group_by(combined) %>%
    summarise(sample_size = sum(n), .groups = "drop")

  # ---- 3. Count selections (1 = selected, 0 = not, NA = not shown) ----
  counts <- meta_sel %>%
    select(combined, question_group, question_code, short_label, order) %>%
    left_join(
      data %>%
        pivot_longer(
          cols = unique(meta_sel$question_code),
          names_to = "question_code",
          values_to = "value"
        ) %>%
        filter(value == 1) %>%
        count(question_code, name = "freq"),
      by = "question_code"
    ) %>%
    mutate(freq = replace_na(freq, 0)) %>%
    group_by(combined, short_label, order) %>%
    summarise(freq = sum(freq), .groups = "drop")

  # ---- 4. Combine & compute percentages ----
  plot_data <- counts %>%
    left_join(sample_sizes, by = "combined") %>%
    mutate(
      pct = 100 * freq / sample_size,
      label = sprintf("%.1f%% (%d)", pct, freq),
      combined = factor(combined, levels = combined_questions),
      short_label = factor(
        short_label,
        levels = meta_sel %>%
          arrange(order) %>%
          distinct(short_label) %>%
          pull(short_label)
      )
    )

  # ---- 5. Plot ----
  ggplot(
    plot_data,
    aes(
      x = fct_rev(short_label),
      y = pct,
      fill = combined
    )
  ) +
    geom_col(
      position = position_dodge(width = 0.8),
      width = 0.8, #thickness of bars
      alpha = 0.8,
      color = "black", #outline color of bars
      linewidth = 0.3
    ) +
    geom_text(
      aes(label = label),
      position = position_dodge(width = 0.8),
      hjust = -0.05,
      size = 3.5,
      color = "black"
    ) +
    coord_flip() +
    scale_y_continuous(
      limits = c(0, 85),
      expand = expansion(mult = c(0, 0.1))
    ) +
    scale_fill_manual(
      name = "",
      values = c(
        Q7  = "#0072B2",
        Q10 = "#D55E00",
        Q13 = "#F0E442"   
      ),
      labels = c(
        Q7  = "Conditions",
        Q10 = "Methods",
        Q13 = "Performance Measures"
      )
    ) +
    scale_x_discrete(
      labels = ~ stringr::str_wrap(.x, wrap_width)
    ) +
    labs(
      x = NULL,
      y = "Percentage of respondents",
      fill = "Question",
      title = "Results weren't reported for all conditions/methods/performance measures because of the intention to..."
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      axis.text.y = element_text(hjust = 1, size = 10, face = "bold"),
      legend.position = "right" #NOTE change to coordinates later e.g., =c(.9,.75)
    )
}

plot_combined_multiselect(data, meta)
```

## Plot Combined Single Select (DELETE)

```{r}
plot_combined_singleselect <- function(
  data = data,
  metadata = meta,
  combined_questions = c("Q5", "Q8", "Q11"),
  wrap_width = 50
) {

  # ---- 1. Select relevant metadata ----
  meta_sel <- metadata %>%
    filter(question_group %in% combined_questions) %>%
    arrange(question_group, order)

  # ---- 2. Compute sample sizes (who SAW the question) ----
  sample_sizes <- meta_sel %>%
    distinct(question_group, question_code) %>%
    group_by(question_group) %>%
    summarise(
      sample_size = sum(!is.na(data[[first(question_code)]])),
      .groups = "drop"
    ) %>%
    rename(combined = question_group)

  # ---- 3. Count selections ----
  counts <- meta_sel %>%
    select(combined = question_group, question_code, value, short_label, order) %>%
    left_join(
      data %>%
        pivot_longer(
          cols = unique(meta_sel$question_code),
          names_to = "question_code",
          values_to = "response"
        ) %>%
        filter(!is.na(response)) %>%
        count(question_code, value = response, name = "freq"),
      by = c("question_code", "value")
    ) %>%
    mutate(freq = replace_na(freq, 0))

  # ---- 4. Compute percentages ----
  plot_data <- counts %>%
    left_join(sample_sizes, by = "combined") %>%
    mutate(
      pct = 100 * freq / sample_size,
      label = sprintf("%.1f%% (%d)", pct, freq),
      combined = factor(combined, levels = combined_questions),
      short_label = factor(
        short_label,
        levels = meta_sel %>%
          arrange(order) %>%
          distinct(short_label) %>%
          pull(short_label)
      )
    )

  # ---- 5. Plot (same visual structure) ----
  ggplot(
    plot_data,
    aes(
      x = fct_rev(short_label),
      y = pct,
      fill = combined
    )
  ) +
    geom_col(
      position = position_dodge(width = 0.8),
      width = 0.8,
      alpha = 0.8,
      color = "black",
      linewidth = 0.3
    ) +
    geom_text(
      aes(label = label),
      position = position_dodge(width = 0.8),
      hjust = -0.05,
      size = 3.5,
      color = "black"
    ) +
    coord_flip() +
    scale_y_continuous(
      limits = c(0, 100),
      expand = expansion(mult = c(0, 0.1))
    ) +
    scale_fill_manual(
      name = "",
      values = c(
        Q5  = "#0072B2",
        Q8  = "#D55E00",
        Q11 = "#F0E442"
      ),
      labels = c(
        Q5  = "Conditions",
        Q8  = "Methods",
        Q11 = "Performance Measures"
      )
    ) +
    scale_x_discrete(
      labels = ~ stringr::str_wrap(.x, wrap_width)
    ) +
    labs(
      x = NULL,
      y = "Percentage of respondents",
      title = str_wrap("Is at least one result reported for every condition/ method/performance measure that was part of the simulations?", 65)
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      axis.text.y = element_text(hjust = 1, size = 10, face = "bold"),
      legend.position = "right"
    )
}

```

## Plot Combined Single Select Questions (DELETE)

```{r}
plot_combined_singleselect <- function(
  data = data,
  metadata = meta,
  combined_questions = c("Q5", "Q8", "Q11"),
  legend_labels = c("Conditions", "Methods", "Performance Measures"),
  title_plot = NULL,
  wrap_width = 50
) {

  # ---- 1. Select relevant metadata ----
  meta_sel <- metadata %>%
    filter(question_group %in% combined_questions) %>%
    arrange(question_group, order)

  # ---- 2. Compute sample sizes (who SAW the question) ----
  sample_sizes <- meta_sel %>%
    distinct(question_group, question_code) %>%
    group_by(question_group) %>%
    summarise(
      sample_size = sum(!is.na(data[[first(question_code)]])),
      .groups = "drop"
    ) %>%
    rename(combined = question_group)

  # ---- 3. Count selections ----
  counts <- meta_sel %>%
    select(combined = question_group, question_code, value, short_label, order) %>%
    left_join(
      data %>%
        pivot_longer(
          cols = unique(meta_sel$question_code),
          names_to = "question_code",
          values_to = "response"
        ) %>%
        filter(!is.na(response)) %>%
        count(question_code, value = response, name = "freq"),
      by = c("question_code", "value")
    ) %>%
    mutate(freq = replace_na(freq, 0))

  # ---- 4. Compute percentages ----
  plot_data <- counts %>%
    left_join(sample_sizes, by = "combined") %>%
    mutate(
      pct = 100 * freq / sample_size,
      label = sprintf("%.1f%% (%d)", pct, freq),
      combined = factor(combined, levels = combined_questions),
      short_label = factor(
        short_label,
        levels = meta_sel %>%
          arrange(order) %>%
          distinct(short_label) %>%
          pull(short_label)
      )
    )

  # ---- 5. Plot (same visual structure) ----
  ggplot(
    plot_data,
    aes(
      x = fct_rev(short_label),
      y = pct,
      fill = combined
    )
  ) +
    geom_col(
      position = position_dodge(width = 0.8),
      width = 0.8,
      alpha = 0.8,
      color = "black",
      linewidth = 0.3
    ) +
    geom_text(
      aes(label = label),
      position = position_dodge(width = 0.8),
      hjust = -0.05,
      size = 3.5,
      color = "black"
    ) +
    coord_flip() +
    scale_y_continuous(
      limits = c(0, 100),
      expand = expansion(mult = c(0, 0.1))
    ) +
    scale_fill_manual(
  name = "",
  values = setNames(
    c("#0072B2", "#D55E00", "#F0E442"),
    combined_questions
  ),
  labels = setNames(
    legend_labels,
    combined_questions
  )
    ) +
    scale_x_discrete(
      labels = ~ stringr::str_wrap(.x, wrap_width)
    ) +
    labs(
      x = NULL,
      y = "Percentage of respondents",
      title = str_wrap(title_plot, 65)
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      axis.text.y = element_text(hjust = 1, size = 10, face = "bold"),
      legend.position = "right"
    )
}
```

## One combined function for all plots

```{r}
plot_combined_questions <- function(
  data,
  metadata,
  combined_questions,
  legend_labels = c("Conditions", "Methods", "Performance Measures"),
  title_plot = combined_questions,
  combine_ab = FALSE,
  wrap_width = 50,
  colors = c("#0072B2", "#D55E00", "#F0E442"),
  y_max = 100,
  show_legend = length(combined_questions) > 1
) {

  # ---- 1. Select & (optionally) map a/b versions ----
  if (combine_ab) {

    question_map <- tibble(
      combined = rep(combined_questions, each = 2),
      question_group = paste0(rep(combined_questions, each = 2), c("a", "b"))
    )

    meta_sel <- metadata %>%
      inner_join(question_map, by = "question_group") %>%
      arrange(combined, order)

  } else {

    meta_sel <- metadata %>%
      filter(question_group %in% combined_questions) %>%
      mutate(combined = question_group) %>%
      arrange(combined, order)
  }

  # ---- 2. Sample sizes (who SAW the question) ----
  if (combine_ab) {

    sample_sizes_ab <- meta_sel %>%
      distinct(combined, question_group, question_code) %>%
      group_by(combined, question_group) %>%
      summarise(
        n = sum(rowSums(!is.na(data[question_code])) > 0),
        .groups = "drop"
      )

    sample_sizes <- sample_sizes_ab %>%
      group_by(combined) %>%
      summarise(sample_size = sum(n), .groups = "drop")

  } else {

    sample_sizes <- meta_sel %>%
      distinct(combined, question_code) %>%
      group_by(combined) %>%
      summarise(
        sample_size = sum(!is.na(data[[first(question_code)]])),
        .groups = "drop"
      )
  }

  # ---- 3. Count selections ----
  long_data <- data %>%
    pivot_longer(
      cols = unique(meta_sel$question_code),
      names_to = "question_code",
      values_to = "value"
    )

  if (combine_ab) {
    long_data <- long_data %>% filter(value == 1)
  } else {
    long_data <- long_data %>% filter(!is.na(value))
  }

  counts <- meta_sel %>%
    select(combined, question_code, short_label, order, value) %>%
    left_join(
      long_data %>%
        count(question_code, value, name = "freq"),
      by = c("question_code", "value")
    ) %>%
    mutate(freq = replace_na(freq, 0)) %>%
    group_by(combined, short_label, order) %>%
    summarise(freq = sum(freq), .groups = "drop")

  # ---- 4. Percentages & factors ----
  plot_data <- counts %>%
    left_join(sample_sizes, by = "combined") %>%
    mutate(
      pct = 100 * freq / sample_size,
      label = sprintf("%.1f%% (%d)", pct, freq),
      combined = factor(combined, levels = combined_questions),
      short_label = factor(
        short_label,
        levels = meta_sel %>%
          arrange(order) %>%
          distinct(short_label) %>%
          pull(short_label)
      )
    )

  # ---- 5. Plot ----
  ggplot(
    plot_data,
    aes(
      x = fct_rev(short_label),
      y = pct,
      fill = combined
    )
  ) +
    geom_col(
      position = position_dodge(width = 0.8),
      width = 0.8,
      alpha = 0.8,
      color = "black",
      linewidth = 0.3
    ) +
    geom_text(
      aes(label = label),
      position = position_dodge(width = 0.8),
      hjust = -0.05,
      size = 3.5
    ) +
    coord_flip() +
    scale_y_continuous(
      limits = c(0, y_max),
      expand = expansion(mult = c(0, 0.1))
    ) +
    scale_fill_manual(
      values = setNames(colors, combined_questions),
      labels = setNames(legend_labels, combined_questions),
      name = ""
    ) +
    scale_x_discrete(
      labels = ~ stringr::str_wrap(.x, wrap_width)
    ) +
    labs(
      x = NULL,
      y = "Percentage",
      title = if (!is.null(title_plot)) stringr::str_wrap(title_plot, wrap_width)
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 10, face = "bold"),
      axis.title.x = element_text(size = 8),
      axis.text.y = element_text(hjust = 1, size = 8, face = "bold"),
      legend.position = if (show_legend) "right" else "none"
    )
}

```

## All Plots

```{r}

# Section 2: Reporting

# Plot for question 5, 8 and 11

p5_8_11 <- plot_combined_questions(data,
                               meta,
                               combined_questions = c("Q5", "Q8", "Q11"),
                               combine_ab = FALSE,
                               title_plot = "Is at least one result reported for every condition/method/performance measure that was part of the simulations?",
                               y_max = 100,
                               wrap_width = 80)

# Plot for question 6, 9, and 12

p6_9_12 <- plot_combined_questions(data,
                               meta,
                               combined_questions = c("Q6", "Q9", "Q12"),
                               combine_ab = FALSE,
                               title_plot = "Does the body of the paper report at least one result for every [Legend]",
                               y_max = 100,
                               wrap_width = 80)


# Plot for question 7, 10, and 13

p7_10_13 <- plot_combined_questions(data,
                               meta,
                               combined_questions = c("Q7", "Q10", "Q13"),
                               combine_ab = TRUE,
                               title_plot = "Results weren't reported for all [Legend] because...",
                               y_max = 100,
                               wrap_width = 80)


# split_combined <- ggarrange(p5_8_11, p6_9_12, nrow = 2)
# ggarrange(split_combined, p7_10_13, nrow = 1)




# Topic 2.4: Missing values/nonconvergence
p14 <- plot_combined_questions(data,
                               meta,
                               combined_questions = "Q14",
                               combine_ab = FALSE,
                               colors = "#D55E00",
                               title_plot = "Is the number of missings/nonconv iters reported?",
                               y_max = 100,
                               wrap_width = 80)

p15 <- plot_combined_questions(data,
                               meta,
                               combined_questions = "Q15",
                               combine_ab = FALSE,
                               colors = "#D55E00",
                               title_plot = "Does the body of the paper report the number of missings/nonconv iters?",
                               y_max = 100,
                               wrap_width = 80)

topic_24 <- ggarrange(p14, p15, nrow = 2)
#plot(topic_24)


p16 <- plot_combined_questions(data,
                               meta,
                               combined_questions = "Q16",
                               combine_ab = TRUE,
                               colors = "#D55E00",
                               title_plot = "The number of missing values/nonconvergent iterations wasn't reported because...",
                               y_max = 75,
                               wrap_width = 80)
#plot(p16)


# Topic 2.5: MCSE
p17 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q17", 
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Were results accompanied by their MCSE's?",
                        y_max = 100,
                        wrap_width = 80)

p18 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q18", 
                        combine_ab = TRUE, 
                        colors = "#D55E00",
                        title_plot = "MCSE's weren't reported because...",
                        y_max = 75,
                        wrap_width = 80) 

# Topic 2.6: Guidelines
p19 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q19", 
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Which research guideline was used?", #Edited for clarity in plot
                        y_max = 100,
                        wrap_width = 80) 


p20 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q20", 
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Why was no research guideline used?",
                        y_max = 75,
                        wrap_width = 80)

# Topic 2.7: Preregistration
p21 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q21", 
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Was (part of) your simulation study preregistered?",
                        y_max = 100,
                        wrap_width = 80)
 
p22 <- plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q22", 
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Why wasn't the simulation study preregistered?",
                        y_max = 75,
                        wrap_width = 80) 


ggarrange(topic_24, p16, p17, p18, p19, p20, p21, p22, nrow = 4, ncol = 2)


plot_combined_questions(data, 
                        meta, 
                        combined_questions = "Q24", 
                        combine_ab = FALSE, 
                        colors = "#D55E00",
                        title_plot = "Why is not all code openly available?",
                        y_max = 100,
                        wrap_width = 40) 


```

## 
